{
  "version": 3,
  "sources": ["../../@lexical/utils/LexicalUtils.dev.js", "../../@lexical/utils/LexicalUtils.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/utils */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\n\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n\n      if (done) {\n        return resolve(processed);\n      }\n\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n\n        handleNextFile();\n      });\n\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n\n    handleNextFile();\n  });\n}\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n\n  return nodes;\n}\n\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n\n  return depth;\n}\n\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return null;\n}\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n\n  return blockNode;\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n\n    let parentNode = node;\n    let childNode = node;\n\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n\n    return null;\n  };\n\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match; // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n\n    if (lexical.$isTextNode(clone)) {\n      clone.__text = node.__text;\n    }\n\n    nodeMap.set(key, clone);\n  }\n\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection();\n\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n\n  return node.getLatest();\n}\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\nexports.$splitNode = lexical.$splitNode;\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\nexports.isHTMLElement = isHTMLElement;\nexports.isMimeType = isMimeType;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalUtils = process.env.NODE_ENV === 'development' ? require('./LexicalUtils.dev.js') : require('./LexicalUtils.prod.js')\nmodule.exports = LexicalUtils;"],
  "mappings": ";;;;;;;;;;;AAAA;AAAA;AAAA;AAQA,QAAI,YAAY;AAChB,QAAI,UAAU;AAGd,aAAS,uBAAuB,YAAY,YAAY;AACtD,iBAAW,QAAQ,eAAa;AAC9B,YAAI,OAAO,cAAc,UAAU;AACjC,gBAAM,eAAe,UAAU,MAAM,GAAG,EAAE,OAAO,OAAK,MAAM,EAAE;AAC9D,kBAAQ,UAAU,IAAI,GAAG,YAAY;AAAA,QACvC;AAAA,MACF,CAAC;AAAA,IACH;AACA,aAAS,4BAA4B,YAAY,YAAY;AAC3D,iBAAW,QAAQ,eAAa;AAC9B,YAAI,OAAO,cAAc,UAAU;AACjC,kBAAQ,UAAU,OAAO,GAAG,UAAU,MAAM,GAAG,CAAC;AAAA,QAClD;AAAA,MACF,CAAC;AAAA,IACH;AACA,aAAS,WAAW,MAAM,qBAAqB;AAC7C,iBAAW,kBAAkB,qBAAqB;AAChD,YAAI,KAAK,KAAK,WAAW,cAAc,GAAG;AACxC,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAaA,aAAS,gBAAgB,OAAO,qBAAqB;AACnD,YAAM,gBAAgB,MAAM,OAAO,UAAU;AAC7C,aAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,cAAM,YAAY,CAAC;AAEnB,cAAM,iBAAiB,MAAM;AAC3B,gBAAM;AAAA,YACJ;AAAA,YACA,OAAO;AAAA,UACT,IAAI,cAAc,KAAK;AAEvB,cAAI,MAAM;AACR,mBAAO,QAAQ,SAAS;AAAA,UAC1B;AAEA,gBAAM,aAAa,IAAI,WAAW;AAClC,qBAAW,iBAAiB,SAAS,MAAM;AAC3C,qBAAW,iBAAiB,QAAQ,MAAM;AACxC,kBAAM,SAAS,WAAW;AAE1B,gBAAI,OAAO,WAAW,UAAU;AAC9B,wBAAU,KAAK;AAAA,gBACb;AAAA,gBACA;AAAA,cACF,CAAC;AAAA,YACH;AAEA,2BAAe;AAAA,UACjB,CAAC;AAED,cAAI,WAAW,MAAM,mBAAmB,GAAG;AACzC,uBAAW,cAAc,IAAI;AAAA,UAC/B,OAAO;AACL,2BAAe;AAAA,UACjB;AAAA,QACF;AAEA,uBAAe;AAAA,MACjB,CAAC;AAAA,IACH;AACA,aAAS,KAAK,cAAc,YAAY;AACtC,YAAM,QAAQ,CAAC;AACf,YAAM,SAAS,gBAAgB,QAAQ,SAAS,GAAG,UAAU;AAC7D,YAAM,MAAM,eAAe,QAAQ,eAAe,KAAK,IAAI,MAAM,kBAAkB,IAAI;AACvF,UAAI,OAAO;AACX,UAAI,QAAQ,UAAU,IAAI;AAE1B,aAAO,SAAS,QAAQ,CAAC,KAAK,GAAG,GAAG,GAAG;AACrC,cAAM,KAAK;AAAA,UACT;AAAA,UACA;AAAA,QACF,CAAC;AAED,YAAI,QAAQ,eAAe,IAAI,KAAK,KAAK,gBAAgB,IAAI,GAAG;AAC9D,iBAAO,KAAK,cAAc;AAC1B;AAAA,QACF,OAAO;AAEL,cAAI,UAAU;AAEd,iBAAO,YAAY,QAAQ,SAAS,MAAM;AACxC,sBAAU,KAAK,eAAe;AAE9B,gBAAI,YAAY,MAAM;AACpB,qBAAO,KAAK,UAAU;AACtB;AAAA,YACF,OAAO;AACL,qBAAO;AAAA,YACT;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,UAAI,SAAS,QAAQ,KAAK,GAAG,GAAG,GAAG;AACjC,cAAM,KAAK;AAAA,UACT;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAEA,aAAO;AAAA,IACT;AAEA,aAAS,UAAU,MAAM;AACvB,UAAI,YAAY;AAChB,UAAI,QAAQ;AAEZ,cAAQ,YAAY,UAAU,UAAU,OAAO,MAAM;AACnD;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAEA,aAAS,sBAAsB,MAAM,OAAO;AAC1C,UAAI,SAAS;AAEb,aAAO,UAAU,MAAM;AACrB,YAAI,kBAAkB,OAAO;AAC3B,iBAAO;AAAA,QACT;AAEA,iBAAS,OAAO,UAAU;AAAA,MAC5B;AAEA,aAAO;AAAA,IACT;AACA,aAAS,uCAAuC,WAAW;AACzD,YAAM,YAAY,oBAAoB,WAAW,UAAQ,QAAQ,eAAe,IAAI,KAAK,CAAC,KAAK,SAAS,CAAC;AAEzG,UAAI,CAAC,QAAQ,eAAe,SAAS,GAAG;AACtC;AACE,gBAAM,MAAM,iBAAiB,UAAU,2CAA2C;AAAA,QACpF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AACA,aAAS,oBAAoB,cAAc,QAAQ;AACjD,UAAI,OAAO;AAEX,aAAO,SAAS,QAAQ,SAAS,KAAK,QAAQ,MAAM;AAClD,YAAI,OAAO,IAAI,GAAG;AAChB,iBAAO;AAAA,QACT;AAEA,eAAO,KAAK,UAAU;AAAA,MACxB;AAEA,aAAO;AAAA,IACT;AACA,aAAS,iBAAiB,MAAM;AAC9B,aAAO,MAAM;AACX,aAAK,QAAQ,OAAK,EAAE,CAAC;AAAA,MACvB;AAAA,IACF;AACA,aAAS,8BAA8B,QAAQ,YAAY,WAAW,eAAe;AACnF,YAAM,gBAAgB,UAAQ;AAC5B,eAAO,gBAAgB;AAAA,MACzB;AAEA,YAAM,aAAa,UAAQ;AAGzB,cAAM,WAAW,KAAK,YAAY;AAElC,iBAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,gBAAM,QAAQ,SAAS;AAEvB,cAAI,cAAc,KAAK,GAAG;AACxB,mBAAO;AAAA,UACT;AAAA,QACF;AAEA,YAAI,aAAa;AACjB,YAAI,YAAY;AAEhB,eAAO,eAAe,MAAM;AAC1B,sBAAY;AACZ,uBAAa,WAAW,UAAU;AAElC,cAAI,cAAc,UAAU,GAAG;AAC7B,mBAAO;AAAA,cACL,OAAO;AAAA,cACP,QAAQ;AAAA,YACV;AAAA,UACF;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAEA,YAAM,uBAAuB,UAAQ;AACnC,cAAM,QAAQ,WAAW,IAAI;AAE7B,YAAI,UAAU,MAAM;AAClB,gBAAM;AAAA,YACJ;AAAA,YACA;AAAA,UACF,IAAI;AAEJ,cAAI,MAAM,GAAG,IAAI,GAAG;AAClB,0BAAc,QAAQ,IAAI;AAC1B,kBAAM,eAAe,MAAM,gBAAgB;AAC3C,kBAAM,qBAAqB,aAAa;AACxC,mBAAO,YAAY,KAAK;AAExB,gBAAI,uBAAuB,GAAG;AAC5B,oBAAM,YAAY,UAAU,MAAM;AAClC,oBAAM,YAAY,SAAS;AAE3B,uBAAS,IAAI,GAAG,IAAI,oBAAoB,KAAK;AAC3C,0BAAU,OAAO,aAAa,EAAE;AAAA,cAClC;AAAA,YACF;AAEA,gBAAI,CAAC,OAAO,WAAW,KAAK,OAAO,gBAAgB,MAAM,GAAG;AAC1D,qBAAO,OAAO;AAAA,YAChB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAO,OAAO,sBAAsB,YAAY,oBAAoB;AAAA,IACtE;AACA,aAAS,oBAAoB,QAAQ,aAAa;AAChD,YAAM,iBAAiB;AACvB,YAAM,UAAU,oBAAI,IAAI;AACxB,YAAM,oBAAoB,OAAO;AAEjC,iBAAW,CAAC,KAAK,IAAI,KAAK,YAAY,UAAU;AAC9C,cAAM,QAAQ,UAAU,qBAAqB,IAAI;AAEjD,YAAI,QAAQ,YAAY,KAAK,GAAG;AAC9B,gBAAM,SAAS,KAAK;AAAA,QACtB;AAEA,gBAAQ,IAAI,KAAK,KAAK;AAAA,MACxB;AAEA,UAAI,mBAAmB;AACrB,0BAAkB,WAAW;AAAA,MAC/B;AAEA,aAAO,aAAa;AACpB,YAAM,cAAc,YAAY;AAChC,cAAQ,cAAc,gBAAgB,OAAO,OAAO,YAAY,MAAM,CAAC;AAAA,IACzE;AACA,aAAS,yBAAyB,MAAM;AACtC,YAAMA,aAAY,QAAQ,cAAc;AAExC,UAAI,QAAQ,kBAAkBA,UAAS,GAAG;AACxC,cAAM;AAAA,UACJ;AAAA,QACF,IAAIA;AACJ,cAAM,YAAY,MAAM,QAAQ;AAChC,cAAM,cAAc,MAAM;AAE1B,YAAI,QAAQ,oBAAoB,SAAS,GAAG;AAC1C,gBAAM,aAAa,UAAU,gBAAgB,WAAW;AAExD,cAAI,cAAc,MAAM;AACtB,sBAAU,OAAO,IAAI;AAAA,UACvB,OAAO;AACL,uBAAW,aAAa,IAAI;AAAA,UAC9B;AAEA,eAAK,WAAW;AAAA,QAClB,OAAO;AACL,cAAI;AACJ,cAAI;AAEJ,cAAI,QAAQ,YAAY,SAAS,GAAG;AAClC,wBAAY,UAAU,iBAAiB;AACvC,0BAAc,UAAU,qBAAqB;AAE7C,gBAAI,cAAc,GAAG;AACnB,6BAAe;AACf,wBAAU,UAAU,WAAW;AAAA,YACjC;AAAA,UACF,OAAO;AACL,wBAAY;AACZ,0BAAc;AAAA,UAChB;AAEA,gBAAM,CAAC,EAAE,SAAS,IAAI,QAAQ,WAAW,WAAW,WAAW;AAC/D,oBAAU,aAAa,IAAI;AAC3B,oBAAU,YAAY;AAAA,QACxB;AAAA,MACF,OAAO;AACL,YAAI,QAAQ,iBAAiBA,UAAS,KAAK,QAAQ,4BAA4BA,UAAS,GAAG;AACzF,gBAAM,QAAQA,WAAU,SAAS;AACjC,gBAAM,MAAM,SAAS,GAAG,0BAA0B,EAAE,YAAY,IAAI;AAAA,QACtE,OAAO;AACL,gBAAM,OAAO,QAAQ,SAAS;AAC9B,eAAK,OAAO,IAAI;AAAA,QAClB;AAEA,cAAM,gBAAgB,QAAQ,qBAAqB;AACnD,aAAK,YAAY,aAAa;AAC9B,sBAAc,OAAO;AAAA,MACvB;AAEA,aAAO,KAAK,UAAU;AAAA,IACxB;AACA,aAAS,mBAAmB,MAAM,mBAAmB;AACnD,YAAM,cAAc,kBAAkB;AACtC,WAAK,QAAQ,WAAW;AACxB,kBAAY,OAAO,IAAI;AACvB,aAAO;AAAA,IACT;AACA,aAAS,oBAAoB,GAAG;AAC9B,aAAO,cAAc,CAAC,KAAK,EAAE,YAAY;AAAA,IAC3C;AACA,aAAS,cAAc,GAAG;AAExB,aAAO,EAAE,aAAa;AAAA,IACxB;AAEA,YAAQ,aAAa,QAAQ;AAC7B,YAAQ,OAAO;AACf,YAAQ,sBAAsB;AAC9B,YAAQ,yCAAyC;AACjD,YAAQ,wBAAwB;AAChC,YAAQ,2BAA2B;AACnC,YAAQ,sBAAsB;AAC9B,YAAQ,qBAAqB;AAC7B,YAAQ,yBAAyB;AACjC,YAAQ,sBAAsB;AAC9B,YAAQ,gBAAgB;AACxB,YAAQ,aAAa;AACrB,YAAQ,kBAAkB;AAC1B,YAAQ,gBAAgB;AACxB,YAAQ,gCAAgC;AACxC,YAAQ,8BAA8B;AAAA;AAAA;;;AC1WtC;AAAA;AAAA;AAOA,QAAM,eAAe,OAAyC,6BAAmC;AACjG,WAAO,UAAU;AAAA;AAAA;",
  "names": ["selection"]
}
