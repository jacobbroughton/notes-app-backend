import {
  require_LexicalList
} from "./chunk-GLR65EFK.js";
import {
  require_LexicalUtils
} from "./chunk-2UNZLLSY.js";
import "./chunk-CDOMP2EE.js";
import {
  require_Lexical
} from "./chunk-6YXZU43S.js";
import {
  require_LexicalComposerContext
} from "./chunk-3IJWP7HA.js";
import {
  require_react
} from "./chunk-S4LFUXEE.js";
import {
  __commonJS
} from "./chunk-TWLJ45QX.js";

// node_modules/@lexical/react/LexicalCheckListPlugin.dev.js
var require_LexicalCheckListPlugin_dev = __commonJS({
  "node_modules/@lexical/react/LexicalCheckListPlugin.dev.js"(exports) {
    "use strict";
    var list = require_LexicalList();
    var LexicalComposerContext = require_LexicalComposerContext();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var react = require_react();
    function CheckListPlugin() {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      react.useEffect(() => {
        return utils.mergeRegister(editor.registerCommand(list.INSERT_CHECK_LIST_COMMAND, () => {
          list.insertList(editor, "check");
          return true;
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, (event) => {
          return handleArrownUpOrDown(event, editor, false);
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, (event) => {
          return handleArrownUpOrDown(event, editor, true);
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, (event) => {
          const activeItem = getActiveCheckListItem();
          if (activeItem != null) {
            const rootElement = editor.getRootElement();
            if (rootElement != null) {
              rootElement.focus();
            }
            return true;
          }
          return false;
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_SPACE_COMMAND, (event) => {
          const activeItem = getActiveCheckListItem();
          if (activeItem != null && editor.isEditable()) {
            editor.update(() => {
              const listItemNode = lexical.$getNearestNodeFromDOMNode(activeItem);
              if (list.$isListItemNode(listItemNode)) {
                event.preventDefault();
                listItemNode.toggleChecked();
              }
            });
            return true;
          }
          return false;
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, (event) => {
          return editor.getEditorState().read(() => {
            const selection = lexical.$getSelection();
            if (lexical.$isRangeSelection(selection) && selection.isCollapsed()) {
              const {
                anchor
              } = selection;
              const isElement = anchor.type === "element";
              if (isElement || anchor.offset === 0) {
                const anchorNode = anchor.getNode();
                const elementNode = utils.$findMatchingParent(anchorNode, (node) => lexical.$isElementNode(node) && !node.isInline());
                if (list.$isListItemNode(elementNode)) {
                  const parent = elementNode.getParent();
                  if (list.$isListNode(parent) && parent.getListType() === "check" && (isElement || elementNode.getFirstDescendant() === anchorNode)) {
                    const domNode = editor.getElementByKey(elementNode.__key);
                    if (domNode != null && document.activeElement !== domNode) {
                      domNode.focus();
                      event.preventDefault();
                      return true;
                    }
                  }
                }
              }
            }
            return false;
          });
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {
          if (rootElement !== null) {
            rootElement.addEventListener("click", handleClick);
            rootElement.addEventListener("pointerdown", handlePointerDown);
          }
          if (prevElement !== null) {
            prevElement.removeEventListener("click", handleClick);
            prevElement.removeEventListener("pointerdown", handlePointerDown);
          }
        }));
      });
      return null;
    }
    function handleCheckItemEvent(event, callback) {
      const target = event.target;
      if (target === null || !utils.isHTMLElement(target)) {
        return;
      }
      const firstChild = target.firstChild;
      if (firstChild != null && utils.isHTMLElement(firstChild) && (firstChild.tagName === "UL" || firstChild.tagName === "OL")) {
        return;
      }
      const parentNode = target.parentNode;
      if (!parentNode || parentNode.__lexicalListType !== "check") {
        return;
      }
      const pageX = event.pageX;
      const rect = target.getBoundingClientRect();
      if (target.dir === "rtl" ? pageX < rect.right && pageX > rect.right - 20 : pageX > rect.left && pageX < rect.left + 20) {
        callback();
      }
    }
    function handleClick(event) {
      handleCheckItemEvent(event, () => {
        const domNode = event.target;
        const editor = findEditor(domNode);
        if (editor != null && editor.isEditable()) {
          editor.update(() => {
            if (event.target) {
              const node = lexical.$getNearestNodeFromDOMNode(domNode);
              if (list.$isListItemNode(node)) {
                domNode.focus();
                node.toggleChecked();
              }
            }
          });
        }
      });
    }
    function handlePointerDown(event) {
      handleCheckItemEvent(event, () => {
        event.preventDefault();
      });
    }
    function findEditor(target) {
      let node = target;
      while (node) {
        if (node.__lexicalEditor) {
          return node.__lexicalEditor;
        }
        node = node.parentNode;
      }
      return null;
    }
    function getActiveCheckListItem() {
      const activeElement = document.activeElement;
      return activeElement != null && activeElement.tagName === "LI" && activeElement.parentNode != null && activeElement.parentNode.__lexicalListType === "check" ? activeElement : null;
    }
    function findCheckListItemSibling(node, backward) {
      let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();
      let parent = node;
      while (sibling == null && list.$isListItemNode(parent)) {
        parent = parent.getParentOrThrow().getParent();
        if (parent != null) {
          sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();
        }
      }
      while (list.$isListItemNode(sibling)) {
        const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();
        if (!list.$isListNode(firstChild)) {
          return sibling;
        }
        sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();
      }
      return null;
    }
    function handleArrownUpOrDown(event, editor, backward) {
      const activeItem = getActiveCheckListItem();
      if (activeItem != null) {
        editor.update(() => {
          const listItem = lexical.$getNearestNodeFromDOMNode(activeItem);
          if (!list.$isListItemNode(listItem)) {
            return;
          }
          const nextListItem = findCheckListItemSibling(listItem, backward);
          if (nextListItem != null) {
            nextListItem.selectStart();
            const dom = editor.getElementByKey(nextListItem.__key);
            if (dom != null) {
              event.preventDefault();
              setTimeout(() => {
                dom.focus();
              }, 0);
            }
          }
        });
      }
      return false;
    }
    exports.CheckListPlugin = CheckListPlugin;
  }
});

// node_modules/@lexical/react/LexicalCheckListPlugin.js
var require_LexicalCheckListPlugin = __commonJS({
  "node_modules/@lexical/react/LexicalCheckListPlugin.js"(exports, module) {
    var LexicalCheckListPlugin = true ? require_LexicalCheckListPlugin_dev() : null;
    module.exports = LexicalCheckListPlugin;
  }
});
export default require_LexicalCheckListPlugin();
//# sourceMappingURL=@lexical_react_LexicalCheckListPlugin.js.map
