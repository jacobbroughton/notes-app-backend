{
  "version": 3,
  "sources": ["../../@lexical/selection/LexicalSelection.dev.js", "../../@lexical/selection/LexicalSelection.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\n\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n\n  if (lexical.$isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n\n  if (lexical.$isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n\n  const firstChild = anchorDOM.firstChild;\n\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n\n  return range;\n}\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    return [];\n  }\n\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  let prevRect;\n\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i]; // Exclude a rect that is the exact same as the last rect. getClientRects() can return\n    // the same rect twice for some elements. A more sophisticated thing to do here is to\n    // merge all the rects together into a set of rects that don't overlap, so we don't\n    // generate backgrounds that are too dark.\n\n    const isDuplicateRect = prevRect && prevRect.top === selectionRect.top && prevRect.left === selectionRect.left && prevRect.width === selectionRect.width && prevRect.height === selectionRect.height; // Exclude selections that span the entire element\n\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n\n    if (isDuplicateRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n\n    prevRect = selectionRect;\n  }\n\n  return selectionRects;\n}\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n\n      styleObject[key.trim()] = value.trim();\n    }\n  }\n\n  return styleObject;\n}\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n\n  return value;\n}\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\n\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\n\nfunction $cloneWithProperties(node) {\n  const latest = node.getLatest();\n  const constructor = latest.constructor; // @ts-expect-error\n\n  const clone = constructor.clone(latest);\n  clone.__parent = latest.__parent;\n  clone.__next = latest.__next;\n  clone.__prev = latest.__prev;\n\n  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\n    return $updateElementNodeProperties(clone, latest);\n  }\n\n  if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\n    return $updateTextNodeProperties(clone, latest);\n  }\n\n  return clone;\n}\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n\n    if (isAnchor || isFocus) {\n      const isBackward = selection.isBackward();\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n\n  return textNode;\n}\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n\n  return point.offset === point.getNode().getChildrenSize();\n}\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n\n  if (lexical.$isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n\n  while (remaining > 0 && currentNode !== null) {\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n\n      while (parentSibling === null) {\n        parent = parent.getParent();\n\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n\n        parentSibling = parent.getPreviousSibling();\n      }\n\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n\n        if (lexical.$isElementNode(parentSibling)) {\n          nextNode = parentSibling.getLastDescendant();\n        } else {\n          nextNode = parentSibling;\n        }\n      }\n    }\n\n    let text = currentNode.getTextContent(); // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n\n    const currentNodeSize = currentNode.getTextContentSize();\n\n    if (!lexical.$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n\n      if (parent != null && parent.getChildrenSize() === 0 && !lexical.$isRootNode(parent)) {\n        parent.remove();\n      }\n\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey(); // See if we can just revert it to what was in the last editor state\n\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = lexical.$getNodeByKey(key);\n\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = lexical.$getPreviousSelection();\n        let target = currentNode;\n\n        if (!currentNode.isSimpleText()) {\n          const textNode = lexical.$createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset; // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = lexical.$createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n\n      remaining = 0;\n    }\n  }\n}\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n\n    return styles;\n  }, { ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n\n  if (selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key; // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n\n  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  } // This is the case where we only selected a single node\n\n\n  if (selectedNodes.length === 1) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n\n  } else {\n    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n      }\n\n      $patchStyle(firstNode, patch);\n    }\n\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length; // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      } // if the entire last node isn't selected, split it\n\n\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      if (endOffset !== 0) {\n        $patchStyle(lastNode, patch);\n      }\n    } // style all the text nodes in between\n\n\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Converts all nodes in the selection that are of one block type to another specified by parameter\n *\n * @param selection\n * @param createElement\n * @returns\n */\n\nfunction $setBlocksType(selection, createElement) {\n  if (selection.anchor.key === 'root') {\n    const element = createElement();\n    const root = lexical.$getRoot();\n    const firstChild = root.getFirstChild();\n\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n\n    return;\n  }\n\n  const nodes = selection.getNodes();\n  let maybeBlock = selection.anchor.getNode().getParentOrThrow();\n\n  if (nodes.indexOf(maybeBlock) === -1) {\n    nodes.push(maybeBlock);\n  }\n\n  if (maybeBlock.isInline()) {\n    maybeBlock = maybeBlock.getParentOrThrow();\n\n    if (nodes.indexOf(maybeBlock) === -1) {\n      nodes.push(maybeBlock);\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!isBlock(node)) {\n      continue;\n    }\n\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\n\nfunction isBlock(node) {\n  if (!lexical.$isElementNode(node) || lexical.$isRootOrShadowRoot(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || lexical.$isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\n\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\n\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n\n    node = parentNode;\n  }\n}\n/** @deprecated */\n\n\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n\n    target.replace(element);\n    return;\n  }\n\n  let topLevelNode = null;\n  let descendants = [];\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i]; // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n\n    if (lexical.$isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = []; // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n\n  let targetIsPrevSibling = false;\n\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n\n    target = target.getParentOrThrow();\n\n    if (lexical.$isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n\n  const emptyElements = new Set(); // Find any top level empty elements\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n\n  const movedNodes = new Set(); // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n\n    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new\n        // element.\n\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n\n          if (lexical.$isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n\n  let lastElement = null; // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n\n  if (lexical.$isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n\n      if (lexical.$isElementNode(firstChild)) {\n        target = firstChild;\n      }\n\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n\n  const prevSelection = lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    lexical.$setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n\n  return defaultValue;\n}\n\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n\n  if (selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]; // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n\n  return styleValue === null ? defaultValue : styleValue;\n}\n\nexports.$addNodeStyle = $addNodeStyle;\nexports.$cloneWithProperties = $cloneWithProperties;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$setBlocksType = $setBlocksType;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\nexports.$wrapNodes = $wrapNodes;\nexports.createDOMRange = createDOMRange;\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalSelection = process.env.NODE_ENV === 'development' ? require('./LexicalSelection.dev.js') : require('./LexicalSelection.prod.js')\nmodule.exports = LexicalSelection;"],
  "mappings": "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",
  "names": []
}
